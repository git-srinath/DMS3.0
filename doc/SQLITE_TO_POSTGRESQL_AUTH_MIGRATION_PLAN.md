# SQLite to PostgreSQL Migration Plan (Auth/Admin/Security)

## Objective
Migrate application **user/auth/admin/security data** from SQLite to PostgreSQL, and run FastAPI with PostgreSQL only (no SQLite dependency), while preserving current behavior and naming conventions.

---

## Why this plan is valid
Your direction is sound.
- Current core metadata already supports PostgreSQL/Oracle paths.
- The remaining SQLite coupling is mostly in auth/admin/security/license modules.
- Consolidating to PostgreSQL improves operational control (backup, access policy, monitoring, HA options) and removes split-database complexity.

---

## Current State Summary

### SQLite-coupled modules (to be migrated)
- `backend/modules/login/fastapi_login.py`
- `backend/modules/admin/fastapi_admin.py`
- `backend/modules/admin/fastapi_access_control.py`
- `backend/modules/security/fastapi_security.py`
- `backend/modules/security/utils.py`
- `backend/modules/license/fastapi_license.py`

### Hard dependencies found
- All modules above use `sqlite_engine` from `backend/database/dbconnect.py`.
- SQLite-specific SQL exists:
  - `datetime('now', ...)`
  - `sqlite_master` table checks
  - `AUTOINCREMENT` DDL in runtime table creation

---

## Target Architecture
- Single PostgreSQL-backed runtime for:
  1. Existing DMS metadata tables
  2. User/auth/admin/security/license tables
- No runtime query path should depend on `sqlite_engine`.
- SQLite file can remain only as optional legacy backup artifact (not active path).

---

## Naming Convention Standard (PostgreSQL)
To align with your metadata convention and avoid case-sensitivity issues:
- Use **lowercase unquoted** table/column names.
- Keep existing names already in app usage (`users`, `roles`, `user_roles`, etc.).
- Keep DMS metadata names as lowercase physical objects where applicable (`dms_*`).
- Avoid quoted uppercase identifiers in PostgreSQL.

---

## Scope: Data Objects to Migrate

### Mandatory auth/admin tables
- `users`
- `user_profiles`
- `roles`
- `user_roles`
- `permission_matrix`
- `password_history`
- `login_audit_log`

### Security/admin extension tables
- `user_module_access`
- `modules`
- `audit_logs` (if used in your deployment)

### Non-DB artifacts (validate separately)
- License file/config managed by license manager
- Notification JSON file (`data/notifications.json`)

---

## Phase Plan

## Phase 0 — Pre-migration decisions
1. Decide whether auth tables share the same PostgreSQL DB/schema as DMS metadata or separate schema (recommended: same DB, dedicated schema optional).
2. Freeze write activity to SQLite during cutover window.
3. Backup SQLite file (`sqlite_app.db`) and PostgreSQL target DB snapshot.

Deliverable: approved migration window + rollback checkpoint.

---

## Phase 1 — PostgreSQL schema preparation
1. Apply current baseline DDL:
   - `doc/database_install_postgresql_current_baseline.sql`
2. Ensure auth/admin/security extension tables exist:
   - `user_module_access`
   - `modules`
   - `audit_logs` (if required by your endpoints)
3. Add indexes equivalent to SQLite usage patterns (username/email lookups, role joins, module lookups).

Deliverable: PostgreSQL schema ready and empty.

---

## Phase 2 — Data migration (SQLite -> PostgreSQL)

## 2.1 Migration sequence (order matters)
1. `roles`
2. `users`
3. `user_profiles`
4. `user_roles`
5. `permission_matrix`
6. `password_history`
7. `login_audit_log`
8. `modules` (if exists)
9. `user_module_access` (if exists)
10. `audit_logs` (if exists)

## 2.2 ID/sequence handling
- Preserve primary key values from SQLite.
- After copy, run `setval(...)` for each PostgreSQL identity/sequence so future inserts do not collide.

## 2.3 Data quality checks
- Row counts per table (source vs target)
- PK uniqueness
- FK integrity (`user_roles`, `permission_matrix`, etc.)
- Spot-check admin accounts and active users

Deliverable: validated PostgreSQL data parity report.

---

## Phase 3 — FastAPI refactor to PostgreSQL-only

## 3.1 Engine/session refactor
- Introduce dedicated auth/admin DB session factory using PostgreSQL engine (from env).
- Replace all `sqlite_engine` imports/usages in migrated modules.

## 3.2 SQL dialect adjustments
Replace SQLite-specific SQL:
- `datetime('now')` -> `CURRENT_TIMESTAMP` / `NOW()`
- `datetime('now', '-15 minutes')` -> `NOW() - INTERVAL '15 minutes'`
- `sqlite_master` table existence check -> `information_schema.tables`
- Runtime `AUTOINCREMENT` DDL -> `GENERATED BY DEFAULT AS IDENTITY`

## 3.3 Runtime create-table behavior
- Prefer migration-driven table creation (DDL files), not runtime dynamic CREATE TABLE where possible.
- If runtime creation remains, make it PostgreSQL-compatible.

Deliverable: app code compiles and runs without SQLite references in active path.

---

## Phase 4 — Integration testing & UAT

## 4.1 Core test matrix
- Login success/failure and lockout timing
- Password reset + history enforcement
- User CRUD (admin)
- Role assignment and permission resolution
- Module access toggles (`user_module_access`)
- License admin APIs

## 4.2 Non-functional checks
- Query latency for login and user list
- Concurrency (simultaneous logins)
- Transaction behavior on failed writes

Deliverable: signed UAT report.

---

## Phase 5 — Cutover
1. Stop app writes.
2. Final delta sync from SQLite (if needed).
3. Switch env/config to PostgreSQL-only for auth/admin/security.
4. Start FastAPI and run smoke tests.
5. Keep SQLite file read-only archived for rollback window.

Deliverable: production cutover confirmation.

---

## Phase 6 — Rollback plan
Trigger rollback if critical auth/admin flows fail.
1. Revert app env to SQLite mode.
2. Restart app.
3. Restore PostgreSQL snapshot if needed.
4. Analyze failure and reattempt in next window.

---

## Risks & Mitigations
- SQL dialect mismatch -> pre-cutover integration tests + SQL conversion checklist.
- Sequence collision -> mandatory post-load sequence reset.
- Hidden SQLite assumptions -> grep audit for `sqlite_engine`, `datetime('now'`, `sqlite_master`.
- Data drift during migration -> write freeze + final delta sync.

---

## Acceptance Criteria (Done Definition)
Migration is complete only when:
1. No active module imports/uses `sqlite_engine` for auth/admin/security/license.
2. All auth/admin/security APIs pass functional tests on PostgreSQL.
3. Source/target row counts and FK checks match.
4. Production runbook + rollback runbook are documented and validated.

---

## Suggested Implementation Order (Practical)
1. Build PostgreSQL auth session factory
2. Refactor `login` module first
3. Refactor `admin` + `access_control`
4. Refactor `security` + `license`
5. Execute data migration
6. Run UAT and cutover

---

## Optional Enhancements
- Add feature flag: `AUTH_DB_BACKEND=sqlite|postgresql` for phased rollout.
- Create one-time migration script (`sqlite_to_postgres_auth_migration.py`) with resumable checkpoints.
- Add CI check that fails if new code imports `sqlite_engine` in auth/admin/security modules.

---

## Oracle Readiness Note
If client deployment needs Oracle for auth/admin/security runtime too, use:
- Full install: `doc/database_install_oracle_full.sql`
- Current baseline install: `doc/database_install_oracle_current_baseline.sql`
- Incremental patch for existing Oracle environments:
  - `doc/database_migration_add_auth_admin_support_oracle.sql`

The Oracle scripts now include runtime-required objects used by admin/security APIs:
- `modules`
- `user_module_access`
- `audit_logs`

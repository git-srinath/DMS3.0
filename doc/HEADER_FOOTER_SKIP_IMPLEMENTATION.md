# Header and Footer Row Skipping - Implementation Guide

## Overview
Many files from external applications (reports, exports, etc.) contain header rows (report titles, date ranges, metadata) and footer rows (totals, summaries, page numbers) that need to be skipped during data extraction. This document outlines the implementation for handling these scenarios.

## Use Cases

### Common Scenarios

1. **Report Files with Headers:**
   ```
   Report: Sales Summary
   Date Range: 2025-01-01 to 2025-01-31
   Generated By: System
   ============================================
   ID    | Name      | Amount
   ============================================
   1     | Product A | 1000
   2     | Product B | 2000
   ============================================
   Total: 3000
   Page 1 of 1
   ```

2. **Excel Reports with Multiple Header Rows:**
   ```
   Row 1: Company Name
   Row 2: Department: Sales
   Row 3: Report Date: 2025-01-15
   Row 4: (empty)
   Row 5: Column1 | Column2 | Column3  <- Actual header
   Row 6: Data starts here...
   ```

3. **Files with Footer Totals:**
   ```
   ... data rows ...
   ============================================
   Total Records: 150
   Grand Total: $50,000.00
   Generated: 2025-01-15 10:30 AM
   ```

## Database Schema

### Additional Columns in `DMS_FLUPLD`

```sql
-- PostgreSQL
ALTER TABLE dms_flupld ADD COLUMN IF NOT EXISTS hdrrwcnt INTEGER DEFAULT 0;            -- Number of header rows to skip
ALTER TABLE dms_flupld ADD COLUMN IF NOT EXISTS ftrrwcnt INTEGER DEFAULT 0;            -- Number of footer rows to skip
ALTER TABLE dms_flupld ADD COLUMN IF NOT EXISTS hdrrwpttrn VARCHAR(500);              -- Header row pattern (regex)
ALTER TABLE dms_flupld ADD COLUMN IF NOT EXISTS ftrrwpttrn VARCHAR(500);              -- Footer row pattern (regex)

-- Oracle
ALTER TABLE DMS_FLUPLD ADD (HDRRWCNT NUMBER DEFAULT 0);
ALTER TABLE DMS_FLUPLD ADD (FTRRWCNT NUMBER DEFAULT 0);
ALTER TABLE DMS_FLUPLD ADD (HDRRWPTTRN VARCHAR2(500));
ALTER TABLE DMS_FLUPLD ADD (FTRRWPTTRN VARCHAR2(500));
```

### Column Descriptions

- **`hdrrwcnt`**: Fixed number of rows to skip from the beginning (e.g., skip first 5 rows)
- **`ftrrwcnt`**: Fixed number of rows to skip from the end (e.g., skip last 3 rows)
- **`hdrrwpttrn`**: Regex pattern to identify header rows dynamically (e.g., `"Report|Title|Date Range"`)
- **`ftrrwpttrn`**: Regex pattern to identify footer rows dynamically (e.g., `"Total|Page|Summary"`)

## Implementation Strategy

### Option 1: Fixed Row Count (Simple)
- User specifies exact number of header/footer rows to skip
- **Pros**: Simple, fast, predictable
- **Cons**: Breaks if report format changes

### Option 2: Pattern-Based Detection (Advanced)
- User provides regex patterns to identify header/footer rows
- System scans file and skips matching rows
- **Pros**: Flexible, handles format variations
- **Cons**: More complex, requires regex knowledge

### Option 3: Interactive Selection (User-Friendly)
- User previews file with row numbers
- User selects which rows are headers/footers
- System stores row numbers or patterns
- **Pros**: Most user-friendly, visual confirmation
- **Cons**: Requires UI implementation

**Recommendation**: Support all three options, with Option 1 as default.

## Parser Implementation

### CSV/TSV Parser

```python
import pandas as pd
import re
from typing import Optional

def parse_csv_with_skip(
    file_path: str,
    header_rows: int = 0,
    footer_rows: int = 0,
    header_pattern: Optional[str] = None,
    footer_pattern: Optional[str] = None,
    **kwargs
) -> pd.DataFrame:
    """
    Parse CSV file with header/footer row skipping
    
    Args:
        file_path: Path to CSV file
        header_rows: Fixed number of header rows to skip
        footer_rows: Fixed number of footer rows to skip
        header_pattern: Regex pattern to identify header rows
        footer_pattern: Regex pattern to identify footer rows
        **kwargs: Other pandas read_csv parameters
    """
    # Read all lines first
    with open(file_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    total_lines = len(lines)
    
    # Determine start and end rows
    start_row = header_rows
    end_row = total_lines - footer_rows if footer_rows > 0 else total_lines
    
    # Pattern-based detection
    if header_pattern:
        pattern = re.compile(header_pattern, re.IGNORECASE)
        for i, line in enumerate(lines):
            if pattern.search(line):
                start_row = max(start_row, i + 1)  # Skip this row and all before
    
    if footer_pattern:
        pattern = re.compile(footer_pattern, re.IGNORECASE)
        for i in range(len(lines) - 1, -1, -1):  # Scan from end
            if pattern.search(lines[i]):
                end_row = min(end_row, i)  # Stop before this row
    
    # Extract relevant lines
    data_lines = lines[start_row:end_row]
    
    # Write to temporary file or use StringIO
    from io import StringIO
    data_content = ''.join(data_lines)
    
    # Parse with pandas
    df = pd.read_csv(StringIO(data_content), **kwargs)
    
    return df
```

### Excel Parser

```python
import pandas as pd
import openpyxl
import re
from typing import Optional

def parse_excel_with_skip(
    file_path: str,
    sheet_name: Optional[str] = None,
    header_rows: int = 0,
    footer_rows: int = 0,
    header_pattern: Optional[str] = None,
    footer_pattern: Optional[str] = None,
    **kwargs
) -> pd.DataFrame:
    """
    Parse Excel file with header/footer row skipping
    """
    # Load workbook
    wb = openpyxl.load_workbook(file_path, data_only=True)
    ws = wb[sheet_name] if sheet_name else wb.active
    
    # Get total rows
    total_rows = ws.max_row
    
    # Determine start and end rows
    start_row = header_rows + 1  # Excel is 1-indexed
    end_row = total_rows - footer_rows + 1 if footer_rows > 0 else total_rows + 1
    
    # Pattern-based detection
    if header_pattern:
        pattern = re.compile(header_pattern, re.IGNORECASE)
        for row_idx in range(1, total_rows + 1):
            row_values = [str(cell.value) if cell.value else '' for cell in ws[row_idx]]
            row_text = ' '.join(row_values)
            if pattern.search(row_text):
                start_row = max(start_row, row_idx + 1)
    
    if footer_pattern:
        pattern = re.compile(footer_pattern, re.IGNORECASE)
        for row_idx in range(total_rows, 0, -1):
            row_values = [str(cell.value) if cell.value else '' for cell in ws[row_idx]]
            row_text = ' '.join(row_values)
            if pattern.search(row_text):
                end_row = min(end_row, row_idx)
    
    # Read data range
    data_range = f"{start_row}:{end_row - 1}"
    
    # Use pandas to read, specifying skiprows
    skiprows = list(range(0, start_row - 1))  # Skip rows before start
    if footer_rows > 0:
        # For footer, we'll read and then drop last N rows
        df = pd.read_excel(file_path, sheet_name=sheet_name, skiprows=skiprows, **kwargs)
        df = df.iloc[:-footer_rows] if footer_rows > 0 else df
    else:
        df = pd.read_excel(file_path, sheet_name=sheet_name, skiprows=skiprows, **kwargs)
    
    return df
```

### PDF Parser (Table Extraction)

```python
import pdfplumber
import pandas as pd
import re
from typing import Optional

def parse_pdf_with_skip(
    file_path: str,
    header_rows: int = 0,
    footer_rows: int = 0,
    header_pattern: Optional[str] = None,
    footer_pattern: Optional[str] = None,
    **kwargs
) -> pd.DataFrame:
    """
    Parse PDF with header/footer row skipping
    Note: PDF table extraction is more complex, may need page-level skipping
    """
    all_tables = []
    
    with pdfplumber.open(file_path) as pdf:
        for page in pdf.pages:
            tables = page.extract_tables()
            
            for table in tables:
                if not table or len(table) < 2:
                    continue
                
                # Convert to DataFrame
                df_page = pd.DataFrame(table[1:], columns=table[0])
                
                # Apply header/footer skipping
                if header_rows > 0:
                    df_page = df_page.iloc[header_rows:]
                
                if footer_rows > 0:
                    df_page = df_page.iloc[:-footer_rows] if len(df_page) > footer_rows else pd.DataFrame()
                
                # Pattern-based detection
                if header_pattern:
                    pattern = re.compile(header_pattern, re.IGNORECASE)
                    drop_indices = []
                    for idx, row in df_page.iterrows():
                        row_text = ' '.join([str(val) for val in row.values if val])
                        if pattern.search(row_text):
                            drop_indices.append(idx)
                    df_page = df_page.drop(drop_indices)
                
                if footer_pattern:
                    pattern = re.compile(footer_pattern, re.IGNORECASE)
                    drop_indices = []
                    for idx, row in df_page.iterrows():
                        row_text = ' '.join([str(val) for val in row.values if val])
                        if pattern.search(row_text):
                            drop_indices.append(idx)
                    df_page = df_page.drop(drop_indices)
                
                all_tables.append(df_page)
    
    # Combine all tables
    if all_tables:
        return pd.concat(all_tables, ignore_index=True)
    else:
        return pd.DataFrame()
```

## UI Implementation

### File Preview with Row Numbers

```javascript
// FilePreviewDialog.js
const FilePreviewDialog = ({ file, onConfirm }) => {
  const [previewData, setPreviewData] = useState([]);
  const [headerRows, setHeaderRows] = useState(0);
  const [footerRows, setFooterRows] = useState(0);
  const [selectedHeaderRows, setSelectedHeaderRows] = useState([]);
  const [selectedFooterRows, setSelectedFooterRows] = useState([]);
  
  // Load preview with row numbers
  useEffect(() => {
    loadPreview();
  }, [file]);
  
  const loadPreview = async () => {
    const response = await fetch(`/file-upload/preview-file?file=${file.id}&rows=50`);
    const data = await response.json();
    setPreviewData(data.rows.map((row, idx) => ({ rowNumber: idx + 1, ...row })));
  };
  
  return (
    <Dialog open={true}>
      <DialogTitle>File Preview - Select Header/Footer Rows</DialogTitle>
      <DialogContent>
        <Box>
          <Typography variant="h6">Header Rows</Typography>
          <TextField
            type="number"
            label="Skip First N Rows"
            value={headerRows}
            onChange={(e) => setHeaderRows(parseInt(e.target.value) || 0)}
            inputProps={{ min: 0 }}
          />
          <TextField
            label="Header Pattern (Regex)"
            placeholder="e.g., Report|Title|Date Range"
            helperText="Rows matching this pattern will be skipped"
          />
        </Box>
        
        <Box>
          <Typography variant="h6">Footer Rows</Typography>
          <TextField
            type="number"
            label="Skip Last N Rows"
            value={footerRows}
            onChange={(e) => setFooterRows(parseInt(e.target.value) || 0)}
            inputProps={{ min: 0 }}
          />
          <TextField
            label="Footer Pattern (Regex)"
            placeholder="e.g., Total|Page|Summary"
            helperText="Rows matching this pattern will be skipped"
          />
        </Box>
        
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Row #</TableCell>
              <TableCell>Select</TableCell>
              <TableCell>Preview</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {previewData.map((row, idx) => (
              <TableRow
                key={idx}
                style={{
                  backgroundColor: 
                    idx < headerRows ? '#ffebee' :  // Header rows
                    idx >= previewData.length - footerRows ? '#fff3e0' :  // Footer rows
                    'transparent'
                }}
              >
                <TableCell>{row.rowNumber}</TableCell>
                <TableCell>
                  <Checkbox
                    checked={selectedHeaderRows.includes(idx) || selectedFooterRows.includes(idx)}
                    onChange={(e) => {
                      if (e.target.checked) {
                        // Add to appropriate list
                        if (idx < headerRows || idx < 5) {
                          setSelectedHeaderRows([...selectedHeaderRows, idx]);
                        } else {
                          setSelectedFooterRows([...selectedFooterRows, idx]);
                        }
                      }
                    }}
                  />
                </TableCell>
                <TableCell>
                  {Object.values(row).slice(1, 6).join(' | ')}...
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </DialogContent>
      <DialogActions>
        <Button onClick={onConfirm}>Confirm</Button>
      </DialogActions>
    </Dialog>
  );
};
```

### Configuration in Upload Form

```javascript
// UploadForm.js - Header Section
<Grid container spacing={2}>
  <Grid item xs={12} md={6}>
    <TextField
      label="Header Rows to Skip"
      type="number"
      value={formData.hdrrwcnt || 0}
      onChange={(e) => setFormData({ ...formData, hdrrwcnt: parseInt(e.target.value) || 0 })}
      inputProps={{ min: 0 }}
      helperText="Number of rows to skip from the beginning"
    />
  </Grid>
  <Grid item xs={12} md={6}>
    <TextField
      label="Footer Rows to Skip"
      type="number"
      value={formData.ftrrwcnt || 0}
      onChange={(e) => setFormData({ ...formData, ftrrwcnt: parseInt(e.target.value) || 0 })}
      inputProps={{ min: 0 }}
      helperText="Number of rows to skip from the end"
    />
  </Grid>
  <Grid item xs={12} md={6}>
    <TextField
      label="Header Pattern (Optional)"
      value={formData.hdrrwpttrn || ''}
      onChange={(e) => setFormData({ ...formData, hdrrwpttrn: e.target.value })}
      placeholder="e.g., Report|Title|Date Range"
      helperText="Regex pattern to identify header rows"
    />
  </Grid>
  <Grid item xs={12} md={6}>
    <TextField
      label="Footer Pattern (Optional)"
      value={formData.ftrrwpttrn || ''}
      onChange={(e) => setFormData({ ...formData, ftrrwpttrn: e.target.value })}
      placeholder="e.g., Total|Page|Summary"
      helperText="Regex pattern to identify footer rows"
    />
  </Grid>
  <Grid item xs={12}>
    <Button
      variant="outlined"
      onClick={openPreviewDialog}
      startIcon={<PreviewIcon />}
    >
      Preview File with Row Selection
    </Button>
  </Grid>
</Grid>
```

## API Endpoints

### Update File Upload Endpoint

```python
@router.post("/file-upload/upload-file")
async def upload_file(
    file: UploadFile = File(...),
    header_rows: int = Form(0),
    footer_rows: int = Form(0),
    header_pattern: Optional[str] = Form(None),
    footer_pattern: Optional[str] = Form(None)
):
    """Upload file with header/footer skip configuration"""
    # Save file temporarily
    file_path = save_uploaded_file(file)
    
    # Parse with skip configuration
    parser = get_parser(file.filename)
    df = parser.parse(
        file_path,
        header_rows=header_rows,
        footer_rows=footer_rows,
        header_pattern=header_pattern,
        footer_pattern=footer_pattern
    )
    
    return {
        "columns": list(df.columns),
        "row_count": len(df),
        "preview": df.head(10).to_dict('records')
    }
```

### Preview Endpoint with Row Numbers

```python
@router.get("/file-upload/preview-file")
async def preview_file(
    file_path: str,
    rows: int = 50,
    header_rows: int = 0,
    footer_rows: int = 0
):
    """Preview file with row numbers and skip configuration"""
    parser = get_parser(file_path)
    
    # Read raw data with row numbers
    raw_data = parser.read_raw_with_row_numbers(file_path, max_rows=rows)
    
    # Apply skip configuration for preview
    preview_data = raw_data[header_rows:]
    if footer_rows > 0:
        preview_data = preview_data[:-footer_rows]
    
    return {
        "rows": preview_data,
        "total_rows": len(raw_data),
        "header_rows": header_rows,
        "footer_rows": footer_rows
    }
```

## Validation Rules

1. **Header Rows:**
   - Must be >= 0
   - Cannot exceed total file rows
   - If pattern provided, pattern is validated as regex

2. **Footer Rows:**
   - Must be >= 0
   - Cannot exceed total file rows
   - Header rows + Footer rows < Total rows

3. **Patterns:**
   - Must be valid regex
   - Tested against sample rows before saving

## Testing Scenarios

1. **Fixed Header/Footer:**
   - File with 5 header rows, 2 footer rows
   - Verify correct rows are skipped

2. **Pattern-Based:**
   - File with "Report:" in first row
   - File with "Total:" in last row
   - Verify pattern matching works

3. **Combined:**
   - Fixed header rows + pattern-based footer
   - Verify both work together

4. **Edge Cases:**
   - Header rows = 0, Footer rows = 0
   - Header rows = total rows (should error)
   - Invalid regex pattern (should error)

## User Experience Flow

1. User uploads file
2. System shows preview with row numbers
3. User can:
   - Enter fixed number of rows to skip
   - Enter regex patterns
   - Visually select rows in preview
4. System applies configuration and shows updated preview
5. User confirms and proceeds to column mapping

## Summary

This implementation provides flexible options for handling header and footer rows:
- **Simple**: Fixed row count (most common use case)
- **Advanced**: Pattern-based detection (handles variations)
- **Interactive**: Visual row selection (user-friendly)

All three methods can be used together for maximum flexibility.

